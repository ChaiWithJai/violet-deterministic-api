[{"author":{"id":"MDQ6VXNlcjQxMDI0ODI4","is_bot":false,"login":"ChaiWithJai","name":"Jai"},"body":"## Scope\nMigration export/import endpoints planned in R1-014 and R1-015 remain unimplemented. Without these, there is no programmatic path for Violet Rails tenants to migrate their structures to VDA.\n\nPattern reference: \\`R1-026\\` in \\`planning/release-r1/tickets.json\\`. Umbrella issue for R1-014 (export) and R1-015 (import), elevated by parity matrix analysis (2026-02-20).\n\n## 1) Gap Description\nProblem surface:\n- \\`POST /v1/migration/violet/export\\` and \\`POST /v1/migration/violet/import\\` are documented in planning tickets (R1-014, R1-015) but have no handler code, no route registration, and no implementation.\n- Docs reference these as required release gates (\\`EXTRACTION_ROADMAP.md\\`, \\`DEPRECATION_PLAN.md\\`) — without them, the deprecation path from Violet Rails has no programmatic foundation.\n- The parity matrix confirms this as the only explicitly \"Missing\" category (not \"Partial\").\n\nEvidence anchors:\n- \\`planning/release-r1/tickets.json:317-363\\` — R1-014 and R1-015 ticket definitions\n- \\`docs/EXTRACTION_ROADMAP.md:3\\` — references migration as required gate\n- \\`docs/DEPRECATION_PLAN.md:4\\` — references migration as prerequisite\n- \\`internal/http/server.go\\` — no \\`/v1/migration/\\` routes registered\n- \\`planning/release-r1/board.json\\` — R1-014 and R1-015 in \"uphill\" column\n\nCode-smell label:\n- \\`Delivery Gap\\` (same as issue #1 Occurrence C, now elevated to standalone tracking)\n\nCode Complete challenge class:\n- \\`Increment planning debt escalated to release-blocking gap\\`\n\nStructural pattern behind the footgun:\n- Core platform work (determinism, auth, studio) was correctly prioritized. But migration endpoints were left in \"planned\" state while docs continued to reference them as gates — creating a gap between documented intent and runtime reality.\n\n## 2) Impact Assessment\n\n**Severity:** Critical for migration path — no programmatic way to move Violet Rails structures into VDA.\n\n**Blocked outcomes:**\n- Tenant data migration from Violet Rails namespaces/resources\n- Automated cutover validation (export → import → diff)\n- Deprecation timeline progress (cannot deprecate what cannot be migrated)\n\n**Current workaround:** Manual re-creation of app structures through VDA's prompt→clarify→generate flow. Works for new apps, not for existing Violet tenants with established data.\n\n## 3) Required Implementation\n\n### Export endpoint: \\`POST /v1/migration/violet/export\\`\n- Accept Violet namespace/resource/action identifiers\n- Produce normalized migration bundle with schema + data versions\n- Report unsupported fields explicitly (not silently drop)\n- Idempotent: same input produces identical bundle\n\n### Import endpoint: \\`POST /v1/migration/violet/import\\`\n- Accept export bundle + target app_id\n- Validate bundle version compatibility\n- Apply migrations with field-level diagnostics\n- Reject partial applies by default (explicit override required)\n- Roundtrip: export → import → export should produce identical bundles\n\n### Migration validation suite\n- Golden fixture translation tests from sampled Violet payloads\n- Compatibility mismatch tests\n- Roundtrip fidelity tests\n\n## 4) RIOA Reflection\n- **Reasoning:** Correct prioritization — platform integrity before migration breadth.\n- **Interpreting:** Migration gap is now the longest pole in the tent. Without it, \"replace Violet Rails\" is aspirational, not achievable.\n- **Observing:** R1-014 and R1-015 have been \"uphill\" since cycle start with no progress toward code.\n- **Acting:** Elevate to P0. Block deprecation timeline progress on passing migration roundtrip tests. Add to M3 or M4 gate.\n\n## Cross-reference\n- R1-014: Implement migration exporter for Violet structures\n- R1-015: Implement migration importer with reject-safe semantics\n- Issue #1 Occurrence C: \"Migration parity/cutover gates documented but unimplemented\"\n- \\`docs/EXTRACTION_ROADMAP.md\\` — migration as required gate\n- \\`docs/DEPRECATION_PLAN.md\\` — deprecation prerequisites\n- RFC-0001 section 13 (\"Migration parity endpoints and production-hardening evidence are still outstanding gates\")\n\n## Checklist\n- [ ] Implement \\`POST /v1/migration/violet/export\\` handler\n- [ ] Implement \\`POST /v1/migration/violet/import\\` handler\n- [ ] Register routes in \\`server.go\\`\n- [ ] Add storage methods for migration bundles\n- [ ] Create golden fixture test suite from sampled Violet payloads\n- [ ] Add roundtrip fidelity test (export → import → export = identical)\n- [ ] Update OpenAPI spec with migration endpoint schemas\n- [ ] Move R1-014/R1-015 from \"uphill\" to active implementation","comments":[],"labels":[],"number":8,"title":"[R1-026] Migration parity endpoints unimplemented — export/import gates outstanding","url":"https://github.com/ChaiWithJai/violet-deterministic-api/issues/8"},{"author":{"id":"MDQ6VXNlcjQxMDI0ODI4","is_bot":false,"login":"ChaiWithJai","name":"Jai"},"body":"## Scope\nVDA has strong request-level tenant auth but lacks user lifecycle management, admin consoles, invitation flows, OTP/2FA, and subdomain governance that Violet Rails provides.\n\nPattern reference: `R1-025` in `planning/release-r1/tickets.json`, derived from parity matrix analysis (2026-02-20).\n\n## 1) Gap Description\nProblem surface:\n- Violet Rails includes: Devise auth, user invitations, OTP verification, sysadmin consoles, subdomain-based tenant isolation, admin approval flows, and role-based access control across UI surfaces.\n- VDA's auth model is token-based (`AUTH_TOKENS` env var format: `token:tenant_id:subject`) — suitable for API consumers and agents, but not for end-user-facing applications.\n- No endpoints exist for: user registration, login, password reset, invitation, role assignment, admin console operations, or subdomain provisioning.\n\nEvidence anchors:\n- `internal/auth/auth.go` — token validation from `AUTH_TOKENS` env, returns `Claims{TenantID, Subject}`\n- `internal/http/server.go:75` — all routes use same token-based auth middleware\n- Violet Rails: `violet_routes.rb:34` — Devise auth, invites, OTP, sysadmin routes\n\nCode-smell label:\n- `Capability Gap`\n\nCode Complete challenge class:\n- `Platform maturity delta`\n\nStructural pattern behind the footgun:\n- VDA's auth was designed for machine-to-machine API access (agents, CI, integrations), not human-facing identity management. This is appropriate for the control plane but insufficient for generated apps that need user-facing auth.\n\n## 2) Impact Assessment\n\n**Severity:** Medium — control-plane auth is solid. The gap is at the generated-app level.\n\n**Where it manifests:**\n- Generated apps cannot authenticate end-users (no login/signup endpoints)\n- No admin console for managing tenant users or roles\n- No invitation workflow for onboarding team members\n- No subdomain isolation for multi-tenant SaaS generated apps\n\n**Current workaround:** Generated apps can include their own auth module (e.g., generated JWT or session-based auth), independent of VDA's control-plane tokens.\n\n## 3) Options\n\n### Option A: Generate auth modules in Studio output (recommended)\n- Studio pipeline generates user auth (registration, login, session, password reset) as part of fullstack output.\n- Generated RBAC model derived from `primary_users` and `constraints` in confirmation.\n- Control-plane tokens remain separate from generated-app user tokens.\n- Preserves determinism: auth module is versioned generated code.\n\n### Option B: Build platform-level identity service\n- Add `/v1/users/*`, `/v1/invitations/*`, `/v1/admin/*` endpoint families.\n- Implement Devise-equivalent flows natively in VDA.\n- Trade-off: enormous scope expansion, conflicts with \"API-first deterministic engine\" identity.\n\n### Option C: Integration adapters for external identity providers\n- Generate integration stubs for Auth0, Clerk, Firebase Auth, Supabase Auth.\n- VDA control plane delegates user auth to external providers.\n- Trade-off: adds dependency but leverages battle-tested identity infrastructure.\n\n## 4) RIOA Reflection\n- **Reasoning:** Separating control-plane auth (machine tokens) from app-level auth (user identity) is architecturally sound.\n- **Interpreting:** The gap isn't that VDA's auth is weak — it's that generated apps need their own auth layer, and the generation pipeline doesn't yet produce it.\n- **Observing:** Most modern SaaS apps use external auth providers anyway. Violet's built-in Devise was convenient but not necessarily best practice.\n- **Acting:** Option A (generate auth modules) + Option C (external provider integration stubs) for maximum flexibility.\n\n## Cross-reference\n- Parity matrix: \"Auth + user/admin governance\" row\n- VDA auth: `internal/auth/auth.go`\n- Violet Rails: Devise auth, invites, OTP at `violet_routes.rb:34`\n- RFC-0001 section 5.6 (\"Policy and role model defaults (RBAC)\")\n- R1-003: AuthN/AuthZ middleware with tenant claims\n- R1-019: Security review checklist and threat model\n\n## Checklist\n- [ ] Define which auth patterns Studio should generate (session, JWT, OAuth)\n- [ ] Implement auth module generation in Studio pipeline from confirmation metadata\n- [ ] Generate RBAC model from `primary_users` + `constraints` confirmation fields\n- [ ] Add integration adapter templates for top 3 external auth providers\n- [ ] Document separation of control-plane auth vs generated-app auth","comments":[],"labels":[],"number":7,"title":"[R1-025] User lifecycle/admin/invite/subdomain governance is light","url":"https://github.com/ChaiWithJai/violet-deterministic-api/issues/7"},{"author":{"id":"MDQ6VXNlcjQxMDI0ODI4","is_bot":false,"login":"ChaiWithJai","name":"Jai"},"body":"## Scope\nStudio generation output is structurally sound but functionally shallow — verification checks are smoke-level (schema/policy/deploy_preflight), not behavioral (does the generated app actually do what the user asked?).\n\nPattern reference: `R1-024` in `planning/release-r1/tickets.json`, derived from parity matrix analysis (2026-02-20).\n\n## 1) Gap Description\nProblem surface:\n- Violet Rails ships built-in product surfaces (CMS, blog, forum, mailbox) with deep, tested behavioral functionality — users get working features, not templates.\n- VDA Studio generates file artifacts with structural quality (correct file structure, runnable previews, schema-valid mutations) but limited behavioral depth.\n- Verification checks (`schema`, `policy`, `deploy_preflight`) test structure, not product behavior.\n- JTBD coverage reporting checks for presence of declared scenarios but does not execute them against generated runtime.\n\nEvidence anchors:\n- `internal/studio/service.go:353` — verification checks are structural\n- `internal/studio/rfc_contracts.go:109` — check model definition\n- `internal/http/studio_handlers.go:155-171` — verification report endpoint\n- `internal/http/studio_handlers.go:173-189` — JTBD coverage endpoint\n\nCode-smell label:\n- `Depth Gap`\n\nCode Complete challenge class:\n- `Verification completeness debt`\n\nStructural pattern behind the footgun:\n- Scaffold-first approach was correct for proving the generation pipeline works end-to-end. But \"generated something that compiles\" ≠ \"generated a product that works.\" The verification layer needs to evolve from structural checks to behavioral assertions.\n\n## 2) Impact Assessment\n\n**Severity:** High — undermines the \"prompt to running app\" JTBD promise. Users expect functional apps, not starter templates.\n\n**Where it manifests:**\n- Generated CRM app has correct file structure but no actual contact management logic\n- Generated e-commerce app has correct routes but no cart/checkout flow\n- Preview renders a shell, not a functioning product\n\n## 3) Options\n\n### Option A: Behavioral test generation (recommended)\n- Generate behavioral test fixtures alongside code artifacts.\n- Run targets (`web`, `mobile`, `api`) execute generated tests, not just compile checks.\n- JTBD coverage runs generated scenarios against generated runtime.\n- Requires: generated test framework scaffolding, runtime execution sandbox.\n\n### Option B: Domain-specific generation templates\n- Pre-built, deeply tested generation templates for common domains (CRM, e-commerce, SaaS admin, content platform).\n- Templates are handcrafted and tested; generation fills in domain-specific details.\n- Trade-off: limited to pre-defined domains, high initial authoring cost.\n\n### Option C: Progressive depth with explicit labeling\n- Label generation output as `prototype`, `pilot`, or `production-candidate` (already in RFC-0001 section 8.2).\n- `prototype` = current depth (scaffold + structural checks).\n- `pilot` = adds behavioral tests + integration stubs.\n- `production-candidate` = full behavioral coverage + deploy readiness.\n- Trade-off: honest about what you get, but \"prototype\" may not satisfy user expectations.\n\n## 4) RIOA Reflection\n- **Reasoning:** Proving the pipeline works end-to-end was the right first step. Depth comes after the skeleton is reliable.\n- **Interpreting:** The gap between \"compilable scaffold\" and \"usable product\" is where the competitive moat lives. This is where VDA either matches Violet's built-in depth or differentiates through verified, deterministic generation.\n- **Observing:** Verification reports currently pass because checks are structural. When checks become behavioral, pass rates will initially drop — this is healthy.\n- **Acting:** Implement Option A (behavioral test generation) in R1 Phase C. Use Option C (depth labeling) immediately as honest UX.\n\n## Cross-reference\n- Parity matrix: \"Generated app depth is scaffold-heavy\" row\n- RFC-0001 section 5.8 (\"Tests and verification report\")\n- RFC-0001 section 9 (Definition of Done requires \"required test suite passes\")\n- R1-010: Verify endpoint with machine-readable verdicts\n- R1-011: Deterministic replay fixture harness\n\n## Checklist\n- [ ] Define behavioral check categories beyond structural (unit, integration, e2e, accessibility)\n- [ ] Implement generated test fixture scaffolding in Studio pipeline\n- [ ] Update run targets to execute behavioral tests, not just compile/lint\n- [ ] Add depth label (`prototype`/`pilot`/`production-candidate`) to Studio job model\n- [ ] Measure and report pass rate delta when behavioral checks are added","comments":[],"labels":[],"number":6,"title":"[R1-024] Generated app depth is scaffold-level, not behavioral","url":"https://github.com/ChaiWithJai/violet-deterministic-api/issues/6"},{"author":{"id":"MDQ6VXNlcjQxMDI0ODI4","is_bot":false,"login":"ChaiWithJai","name":"Jai"},"body":"## Scope\nVDA's mutation model is constrained to 4 classes (`set_name`, `set_plan`, `set_region`, `set_feature_flag`) versus Violet Rails' richer dynamic resource/action/form system.\n\nPattern reference: `R1-023` in `planning/release-r1/tickets.json`, derived from parity matrix analysis (2026-02-20).\n\n## 1) Gap Description\nProblem surface:\n- Violet Rails exposes a dynamic namespace/resource/action layer: `api/:version/:api_namespace/:api_resource/:id/:api_action` — users define custom resources, forms, and actions at runtime.\n- VDA's mutation endpoint (`POST /v1/apps/{id}/mutations`) only supports 4 hardcoded mutation classes with simple key-value semantics.\n- The gap is not just breadth but paradigm: Violet allows arbitrary resource CRUD; VDA enforces constrained, policy-checked mutations.\n\nEvidence anchors:\n- `internal/http/handlers.go:262-290` — mutation handler, switch on 4 classes\n- `internal/http/handlers.go:333-380` — `executeMutation` with `set_name`, `set_plan`, `set_region`, `set_feature_flag`\n- Violet Rails: `api/:version/:api_namespace/...` dynamic resource routing\n\nCode-smell label:\n- `Paradigm Gap`\n\nCode Complete challenge class:\n- `Essential complexity difference in data modeling approach`\n\nStructural pattern behind the footgun:\n- VDA chose constrained mutations deliberately — each mutation class is policy-checked, audited, and replay-safe. Dynamic resource CRUD would require either (a) relaxing determinism constraints or (b) implementing a meta-model that generates resource mutations from schema definitions.\n\n## 2) Impact Assessment\n\n**Severity:** High — limits what generated apps can express without custom code.\n\n**Affected surface:** Any app that needs:\n- Custom entity CRUD beyond the 4 built-in mutations\n- User-defined forms with field-level validation\n- Dynamic API actions triggered by workflow events\n- Multi-entity relationship mutations (e.g., \"add user to team\")\n\n**Current workaround:** Blueprint JSON (`PATCH /v1/apps/{id}`) allows arbitrary key-value patching, but bypasses mutation audit trail and policy checks.\n\n## 3) Options\n\n### Option A: Schema-driven mutation expansion (recommended)\n- Define a blueprint schema language where apps declare their entities/fields/actions.\n- Mutation endpoint validates against declared schema rather than hardcoded classes.\n- New mutation classes: `create_entity`, `update_field`, `execute_action`, `add_relationship`.\n- Preserves determinism: schema is versioned, mutations are still policy-checked.\n\n### Option B: Generate mutation handlers per app\n- Studio generates custom mutation handlers from confirmation metadata (`data_entities`, `core_workflows`).\n- Each generated app gets its own mutation surface derived from domain model.\n- Trade-off: mutation behavior is per-job, not per-platform.\n\n### Option C: Accept the constraint as architectural boundary\n- Document that VDA is not a dynamic data platform but a deterministic build/deploy engine.\n- Rich data CRUD lives in the generated app's own API surface, not VDA's control plane.\n- Trade-off: honest separation of concerns but requires generated apps to be self-sufficient.\n\n## 4) RIOA Reflection\n- **Reasoning:** The 4-class constraint is intentional — it keeps the control plane auditable and replay-safe.\n- **Interpreting:** The gap is about where rich data operations live: in VDA's control plane (like Violet) or in the generated app's runtime.\n- **Observing:** Generated apps already have their own API surfaces via Studio code generation. The \"gap\" may be a feature if framed correctly.\n- **Acting:** Option C for now (separation of concerns), with Option A as the R2 investment if tenants need richer control-plane mutations.\n\n## Cross-reference\n- Parity matrix: \"Dynamic API namespace/resource/form/action model\" row\n- VDA handlers: `handlers.go:333`\n- Violet Rails: `api/:version/:api_namespace/...` routing\n- RFC-0001 section 6.1 (generation pipeline produces domain model + workflows)\n\n## Checklist\n- [ ] Inventory most-used Violet Rails resource types and action patterns\n- [ ] Evaluate Option A (schema-driven mutations) technical feasibility\n- [ ] Ensure Studio generation produces self-sufficient CRUD for declared `data_entities`\n- [ ] Document architectural boundary: control-plane mutations vs generated-app data operations","comments":[],"labels":[],"number":5,"title":"[R1-023] Dynamic API namespace/resource/form/action model not matched","url":"https://github.com/ChaiWithJai/violet-deterministic-api/issues/5"},{"author":{"id":"MDQ6VXNlcjQxMDI0ODI4","is_bot":false,"login":"ChaiWithJai","name":"Jai"},"body":"## Scope\nVDA has no API surface for CMS, blog, forum, or email capabilities that are core to Violet Rails' \"out-of-box SaaS platform\" promise.\n\nPattern reference: `R1-022` in `planning/release-r1/tickets.json`, derived from parity matrix analysis (2026-02-20).\n\n## 1) Gap Description\nProblem surface:\n- Violet Rails ships built-in product surfaces: CMS pages, blog engine, forum/community, mailbox/email tracking — all wired through `violet_routes.rb`.\n- VDA has zero endpoints or handler code for content management, threaded discussions, or email operations.\n- Users migrating from Violet Rails will lose core product modules that their end-users depend on.\n\nEvidence anchors:\n- `internal/http/server.go:75-107` — no content/community/email routes registered\n- `internal/http/handlers.go` — no CMS/blog/forum handlers\n- Violet Rails routes: `violet_routes.rb:46` (CMS), `violet_routes.rb:175` (email/mailbox)\n\nCode-smell label:\n- `Feature Gap`\n\nCode Complete challenge class:\n- `Platform capability parity debt`\n\nStructural pattern behind the footgun:\n- VDA was designed as an API-first deterministic engine, not a product runtime. Built-in product modules require a fundamentally different architecture (template rendering, content storage, notification delivery) that conflicts with VDA's replay-safe, deterministic contracts.\n\n## 2) Impact Assessment\n\n**Severity:** High — blocks migration for any Violet tenant using CMS, blog, forum, or email features.\n\n**Affected user population:** Any Violet Rails tenant with:\n- Published CMS pages (marketing, docs, help center)\n- Active blog posts\n- Community forum threads\n- Email campaign/tracking features\n\n**Workaround available:** Users could wire external services (Ghost for blog, Discourse for forum, SendGrid for email) through VDA integration stubs, but this requires manual setup and loses the \"one platform\" value prop.\n\n## 3) Options\n\n### Option A: Generate as Studio output (recommended short-term)\n- Teach the Studio generation pipeline to scaffold CMS/blog/forum/email modules as part of generated fullstack apps.\n- These become generated code, not built-in runtime features.\n- Preserves determinism: generated modules are versioned artifacts.\n- Trade-off: quality depends on generation depth, not handcrafted product UX.\n\n### Option B: Build native API surface\n- Add `/v1/content/*`, `/v1/forum/*`, `/v1/email/*` endpoint families.\n- Full parity with Violet Rails content/community layer.\n- Trade-off: massive scope expansion, conflicts with fixed-time cycle appetite.\n\n### Option C: Defer with explicit migration adapter\n- Document the gap and provide Violet → external-service migration guides.\n- Studio generates integration stubs for popular alternatives.\n- Trade-off: honest about capability boundary but weakens \"replace Violet\" narrative.\n\n## 4) RIOA Reflection\n- **Reasoning:** VDA's deterministic architecture intentionally avoids dynamic content rendering to preserve replay safety.\n- **Interpreting:** This gap is structural, not accidental — it reflects an architectural choice. The question is whether to grow into it or compose around it.\n- **Observing:** Violet tenants with heavy CMS/forum usage cannot migrate without losing product functionality.\n- **Acting:** Generate product modules via Studio (Option A) for near-term, evaluate native surface (Option B) for future cycles.\n\n## Cross-reference\n- Parity matrix: \"Content/community/email\" row\n- Violet Rails source: `violet_routes.rb` lines 46, 175\n- RFC-0001 section 4 (non-goal: \"Full parity with every historical Violet Rails capability in one cycle\")\n\n## Checklist\n- [ ] Inventory which Violet Rails content/community/email features are most used by active tenants\n- [ ] Define Studio generation templates for CMS, blog, forum modules\n- [ ] Add migration guide for tenants using these features\n- [ ] Update RFC-0001 with explicit scope boundary documentation","comments":[],"labels":[],"number":4,"title":"[R1-022] Missing built-in product primitives (CMS/blog/forum/email)","url":"https://github.com/ChaiWithJai/violet-deterministic-api/issues/4"},{"author":{"id":"MDQ6VXNlcjQxMDI0ODI4","is_bot":false,"login":"ChaiWithJai","name":"Jai"},"body":"## Scope\nClose the template-parity gap by forcing one decision-tree branch and removing contract drift that blocks trustworthy rendered product output.\n\nPattern reference: `R1-021` in `planning/release-r1/tickets.json` and RFC addendum section 13.\n\n## 1) Occurrence A\nProblem surface:\n- Web UI contract expects response shapes that differ from current API payloads in plan/clarify/studio flows.\n\nEvidence anchors:\n- `web/src/lib/api/types.ts:124`\n- `web/src/lib/api/types.ts:131`\n- `web/src/lib/api/types.ts:157`\n- `web/src/routes/Home.svelte:36`\n- `web/src/routes/Home.svelte:49`\n- `web/src/routes/Home.svelte:77`\n- `web/src/routes/Studio.svelte:51`\n- `internal/http/handlers.go:607`\n- `internal/http/handlers.go:678`\n- `internal/http/studio_handlers.go:95`\n\nCode-smell label:\n- `Contract Drift`\n\nCode Complete challenge class:\n- `Essential complexity surfaced as accidental complexity in interface contracts`\n\nStructural pattern behind the footgun:\n- UI typed contracts evolved independently from backend response contracts, causing rendering flow assumptions to diverge.\n\n## 2) Occurrence B\nProblem surface:\n- End-user harness acceptance criteria specify `/ui/harness.html`, but runtime only serves bundled `/ui/` assets.\n\nEvidence anchors:\n- `docs/prd/PRD_END_USER_WEB_CLIENT_HARNESS.md:140`\n- `internal/http/server.go:72`\n- `internal/http/server.go:73`\n\nCode-smell label:\n- `Spec-to-Implementation Drift`\n\nCode Complete challenge class:\n- `Requirements traceability gap`\n\nStructural pattern behind the footgun:\n- Product contract evolved in PRD while route registration converged to a single Svelte bundle entrypoint, leaving documented path stale.\n\n## 3) Occurrence C\nProblem surface:\n- Migration parity/cutover gates are still documented as required but migration API surfaces are not implemented.\n\nEvidence anchors:\n- `docs/EXTRACTION_ROADMAP.md:3`\n- `docs/DEPRECATION_PLAN.md:4`\n- `planning/release-r1/tickets.json:317`\n- `planning/release-r1/tickets.json:341`\n- `internal/http/server.go:75`\n\nCode-smell label:\n- `Delivery Gap`\n\nCode Complete challenge class:\n- `Increment planning debt`\n\nStructural pattern behind the footgun:\n- Foundation work advanced quickly, but migration endpoints remained in planning artifacts only.\n\n## Cross-pattern\n- Repeated mismatch between declared contract (PRD/types/tickets) and runtime truth (registered endpoints + response payloads).\n\n## Previously Applied Principles (likely)\n- Determinism first (idempotency/replay/tenant isolation).\n- Fixed-time, variable-scope release discipline.\n\n## RIOA Reflection\n- Reasoning: deterministic infrastructure was prioritized to de-risk platform integrity.\n- Interpreting: template-grade perception now depends on contract alignment and branch focus, not just more generated artifacts.\n- Observing: core runtime checks pass while product-level confidence erodes where contracts drift.\n- Acting: enforce one branch, align contracts first, and gate progression with end-to-end evidence.\n\n## New Principles To Add\n1. UI types must be generated from OpenAPI or validated against live response fixtures before merge.\n2. PRD route-level acceptance criteria must map to active runtime paths with automated smoke checks.\n3. Each cycle must declare one active branch (platform-first or template-first); non-selected branch items are explicitly cut/deferred.\n\n## Engineer Inventory (Code/Config/Supply Chain)\nCode:\n- `internal/http/handlers.go`\n- `internal/http/studio_handlers.go`\n- `internal/http/server.go`\n- `web/src/lib/api/types.ts`\n- `web/src/routes/Home.svelte`\n- `web/src/routes/Studio.svelte`\n- `docs/rfc/RFC-0001-fullstack-violet-rails-output.md`\n\nConfig:\n- `planning/release-r1/board.json`\n- `planning/release-r1/tickets.json`\n\nSupply chain/runtime:\n- Svelte/Vite frontend bundle path serving via embedded UI assets.\n- Go runtime endpoint registration in `net/http` mux.\n\n## Checklist\n- [ ] Select one active decision-tree branch for current cycle and record cuts.\n- [ ] Align web API types to backend payloads (plan/clarify/studio) and verify in UI smoke flow.\n- [ ] Reconcile harness route contract (`/ui/harness.html` vs `/ui/`) in PRD and runtime.\n- [ ] Define migration parity API implementation path or explicitly defer it with cut criteria.\n- [ ] Capture passing evidence for `studio create -> run all -> verification/jtbd` in release artifacts.\n","comments":[],"labels":[],"number":1,"title":"[R1-021] Close template-parity gap with explicit decision-tree execution","url":"https://github.com/ChaiWithJai/violet-deterministic-api/issues/1"}]

package studio

import (
	"fmt"
	"sort"
	"strings"
)

func backendRuntimeArtifacts(slug string, conf Confirmation) []FileArtifact {
	base := fmt.Sprintf("apps/%s/services/api", slug)
	module := fmt.Sprintf("generated/%s/services/api", slug)
	appName := fallback(conf.AppName, "Generated App")
	domain := fallback(conf.Domain, "saas")

	workflowList := `[]string{"` + strings.Join(withDefault(conf.CoreWorkflows, "approve_request"), `", "`) + `"}`
	entityList := `[]string{"` + strings.Join(withDefault(conf.DataEntities, "account"), `", "`) + `"}`
	userList := `[]string{"` + strings.Join(withDefault(conf.PrimaryUsers, "admin"), `", "`) + `"}`

	goMod := fmt.Sprintf(`module %s

go 1.22
`, module)

	readme := fmt.Sprintf(`# %s API Service

Deterministic backend scaffold generated by Violet Studio.

## Run local

1. go run ./cmd/server
2. curl -s http://localhost:8090/health
3. curl -s http://localhost:8090/v1/tools

## Deterministic guarantees

1. Tenant-scoped operations
2. Replay-safe tool contracts
3. Explicit policy constraint defaults
`, appName)

	dockerfile := `FROM golang:1.22-alpine AS build
WORKDIR /app
COPY . .
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o /out/app ./cmd/server

FROM alpine:3.20
RUN adduser -D -g '' appuser
USER appuser
WORKDIR /home/appuser
COPY --from=build /out/app /usr/local/bin/app
EXPOSE 8090
ENTRYPOINT ["/usr/local/bin/app"]
`

	mainGo := fmt.Sprintf(`package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"%s/internal/runtime"
	"%s/internal/tools"
)

func main() {
	spec := runtime.Spec{
		AppName:    %q,
		Domain:     %q,
		Plan:       %q,
		Region:     %q,
		Users:      %s,
		Entities:   %s,
		Workflows:  %s,
		ToolRoutes: tools.Catalog(),
	}

	server := runtime.NewServer(spec)
	port := os.Getenv("PORT")
	if port == "" {
		port = "8090"
	}
	addr := ":" + port
	log.Println("listening on", addr)
	if err := http.ListenAndServe(addr, server.Handler()); err != nil {
		log.Fatal(fmt.Errorf("listen %%s: %%w", addr, err))
	}
}
`, module, module, appName, domain, fallback(conf.Plan, "starter"), fallback(conf.Region, "us-east-1"), userList, entityList, workflowList)

	runtimeServer := `package runtime

import (
	"encoding/json"
	"net/http"
	"time"
)

type Spec struct {
	AppName    string   ` + "`json:\"app_name\"`" + `
	Domain     string   ` + "`json:\"domain\"`" + `
	Plan       string   ` + "`json:\"plan\"`" + `
	Region     string   ` + "`json:\"region\"`" + `
	Users      []string ` + "`json:\"users\"`" + `
	Entities   []string ` + "`json:\"entities\"`" + `
	Workflows  []string ` + "`json:\"workflows\"`" + `
	ToolRoutes []Tool   ` + "`json:\"tool_routes\"`" + `
}

type Tool struct {
	Name        string ` + "`json:\"name\"`" + `
	Method      string ` + "`json:\"method\"`" + `
	Path        string ` + "`json:\"path\"`" + `
	Description string ` + "`json:\"description\"`" + `
}

type Server struct {
	spec Spec
	mux  *http.ServeMux
}

func NewServer(spec Spec) *Server {
	s := &Server{
		spec: spec,
		mux:  http.NewServeMux(),
	}
	s.routes()
	return s
}

func (s *Server) Handler() http.Handler {
	return s.mux
}

func (s *Server) routes() {
	s.mux.HandleFunc("/health", s.handleHealth)
	s.mux.HandleFunc("/v1/tools", s.handleTools)
	s.mux.HandleFunc("/v1/workflows/execute", s.handleExecuteWorkflow)
	s.mux.HandleFunc("/v1/entities", s.handleEntities)
}

func (s *Server) handleHealth(w http.ResponseWriter, _ *http.Request) {
	writeJSON(w, http.StatusOK, map[string]any{
		"status":     "ok",
		"app_name":   s.spec.AppName,
		"domain":     s.spec.Domain,
		"generated":  true,
		"checked_at": time.Now().UTC().Format(time.RFC3339),
	})
}

func (s *Server) handleTools(w http.ResponseWriter, _ *http.Request) {
	writeJSON(w, http.StatusOK, map[string]any{
		"tools": s.spec.ToolRoutes,
		"count": len(s.spec.ToolRoutes),
	})
}

func (s *Server) handleExecuteWorkflow(w http.ResponseWriter, r *http.Request) {
	type request struct {
		Workflow string         ` + "`json:\"workflow\"`" + `
		Input    map[string]any ` + "`json:\"input\"`" + `
	}
	var req request
	_ = json.NewDecoder(r.Body).Decode(&req)
	writeJSON(w, http.StatusOK, map[string]any{
		"workflow":  req.Workflow,
		"status":    "accepted",
		"idempotent": true,
		"input":     req.Input,
		"timestamp": time.Now().UTC().Format(time.RFC3339),
	})
}

func (s *Server) handleEntities(w http.ResponseWriter, _ *http.Request) {
	writeJSON(w, http.StatusOK, map[string]any{
		"entities": s.spec.Entities,
		"count":    len(s.spec.Entities),
	})
}

func writeJSON(w http.ResponseWriter, status int, body any) {
	payload, _ := json.Marshal(body)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	_, _ = w.Write(payload)
}
`

	toolsCatalog := fmt.Sprintf(`package tools

import "%s/internal/runtime"

func Catalog() []runtime.Tool {
	return []runtime.Tool{
		{
			Name:        "plan",
			Method:      "POST",
			Path:        "/v1/agents/plan",
			Description: "Plan structured work for the tenant",
		},
		{
			Name:        "act",
			Method:      "POST",
			Path:        "/v1/agents/act",
			Description: "Execute an idempotent mutation",
		},
		{
			Name:        "verify",
			Method:      "POST",
			Path:        "/v1/agents/verify",
			Description: "Verify outputs before deployment",
		},
		{
			Name:        "deploy",
			Method:      "POST",
			Path:        "/v1/agents/deploy",
			Description: "Prepare self-host or managed deploy intent",
		},
	}
}
`, module)

	toolContracts := fmt.Sprintf(`export type DeterministicTool = {
  name: string;
  method: "POST" | "GET" | "PATCH";
  path: string;
  tenantScoped: true;
  idempotent: boolean;
};

export const TOOL_CONTRACTS: DeterministicTool[] = [
  { name: "plan", method: "POST", path: "/v1/agents/plan", tenantScoped: true, idempotent: true },
  { name: "act", method: "POST", path: "/v1/agents/act", tenantScoped: true, idempotent: true },
  { name: "verify", method: "POST", path: "/v1/agents/verify", tenantScoped: true, idempotent: true },
  { name: "deploy", method: "POST", path: "/v1/agents/deploy", tenantScoped: true, idempotent: true },
];

export const APP_DOMAIN = %q;
`, domain)

	policyFile := fmt.Sprintf(`version: v1
constraints:
  - all_mutations_idempotent
  - no_runtime_eval
  - tenant_scope_required
workflows:
%s
users:
%s
entities:
%s
`, toYAMLList(withDefault(conf.CoreWorkflows, "approve_request")), toYAMLList(withDefault(conf.PrimaryUsers, "admin")), toYAMLList(withDefault(conf.DataEntities, "account")))

	runtimeTest := `package runtime

import (
	"net/http"
	"net/http/httptest"
	"testing"
)

func TestHealthEndpoint(t *testing.T) {
	server := NewServer(Spec{AppName: "Test App", Domain: "saas"})
	req := httptest.NewRequest(http.MethodGet, "/health", nil)
	rec := httptest.NewRecorder()
	server.Handler().ServeHTTP(rec, req)
	if rec.Code != http.StatusOK {
		t.Fatalf("expected status 200, got %d", rec.Code)
	}
}
`

	smokeScript := `#!/usr/bin/env sh
set -eu
BASE_URL="${BASE_URL:-http://localhost:8090}"
curl -fsS "$BASE_URL/health" >/dev/null
curl -fsS "$BASE_URL/v1/tools" >/dev/null
echo "smoke-ok"
`

	files := []FileArtifact{
		{Path: base + "/README.md", Language: "markdown", Content: readme},
		{Path: base + "/go.mod", Language: "go", Content: goMod},
		{Path: base + "/Dockerfile", Language: "dockerfile", Content: dockerfile},
		{Path: base + "/cmd/server/main.go", Language: "go", Content: mainGo},
		{Path: base + "/internal/runtime/server.go", Language: "go", Content: runtimeServer},
		{Path: base + "/internal/runtime/server_test.go", Language: "go", Content: runtimeTest},
		{Path: base + "/internal/tools/catalog.go", Language: "go", Content: toolsCatalog},
		{Path: base + "/internal/policy/rules.yaml", Language: "yaml", Content: policyFile},
		{Path: base + "/internal/tools/contracts.ts", Language: "typescript", Content: toolContracts},
		{Path: base + "/tests/smoke.sh", Language: "bash", Content: smokeScript},
	}

	integrations := conf.Integrations
	if len(integrations) == 0 {
		integrations = []string{"platform"}
	}
	for _, integration := range integrations {
		name := sanitizeIntegrationName(integration)
		typeName := integrationTypeName(name)
		files = append(files, FileArtifact{
			Path:     fmt.Sprintf("%s/internal/integrations/%s_adapter.go", base, name),
			Language: "go",
			Content: fmt.Sprintf(`package integrations

// %[1]sAdapter is a generated integration seam for deterministic workflows.
type %[1]sAdapter struct{}

func (a %[1]sAdapter) Name() string {
	return %[2]q
}

func (a %[1]sAdapter) ValidateConfig(cfg map[string]string) bool {
	return cfg != nil
}
`, typeName, integration),
		})
	}

	sort.Slice(files, func(i, j int) bool { return files[i].Path < files[j].Path })
	return files
}

func sanitizeIntegrationName(value string) string {
	value = strings.ToLower(strings.TrimSpace(value))
	if value == "" {
		return "integration"
	}
	var b strings.Builder
	for _, r := range value {
		if (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') {
			b.WriteRune(r)
			continue
		}
		if b.Len() == 0 || b.String()[b.Len()-1] == '_' {
			continue
		}
		b.WriteRune('_')
	}
	out := strings.Trim(b.String(), "_")
	if out == "" {
		return "integration"
	}
	return out
}

func integrationTypeName(value string) string {
	value = strings.TrimSpace(value)
	if value == "" {
		return "Integration"
	}
	parts := strings.Split(value, "_")
	var b strings.Builder
	for _, part := range parts {
		if part == "" {
			continue
		}
		runes := []rune(part)
		if len(runes) == 0 {
			continue
		}
		first := runes[0]
		if first >= 'a' && first <= 'z' {
			first = first - ('a' - 'A')
		}
		b.WriteRune(first)
		if len(runes) > 1 {
			b.WriteString(string(runes[1:]))
		}
	}
	if b.Len() == 0 {
		return "Integration"
	}
	return b.String()
}
